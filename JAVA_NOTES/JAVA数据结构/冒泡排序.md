# 1. 原理

## 1.1 原理图

![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)



## 1.2 特点

1. 每一次都会将最大的数，放在最后；

2. 每一次只能将一个数归位；以此类推，会执行n-1次;只需要归位至第二位,剩下的一位自然就是正确的位置上了；
3. 每一次都需要从第一位开始，对相邻的两个元素进行比较；比较完成后，向后挪一位，再继续进行比较，直到最后一个；

# 2.实现

## 2.1 实现步骤

1. 比较相邻元素，若arr[i] > arr[i+1],则交换位置；
2. 每一对相邻元素都要进行比较，从开始的第一对，到末尾的最后一对；
3. 每一轮比较结束后，最后的元素会是最大的数；
4. 每一轮比较，比较的次数会-1，因为每一轮比较后，最后的元素已经是最大的，不需要再进行比较；

## 2.2 实现代码

### 2.2.1 基础实现

```java
int[] arr = {1,3,2,5,7,6,9,8};
for(int i = 0;i<arr.length-1;i++){  //外层循环，控制循环的次数，只需要n-1次即可；即控制归位的个数，只需要归位n-1个数就可以了，剩下的一个就会在正确的位置上；
  for(int j = 0;j<arr.length-1-i;i++){  //内层循环，控制元素比较的次数，在n-1次的基础上，减去外层循环已经执行的次数i，就是需要比较的次数；不减也可以实现排序，但会重复判断，影响执行的效率；
   	if(arr[i] > arr[i+1]){
      int temp = arr[i];
      arr[i] = arr[i+1];
      arr[i+1] = temp;
    }
  }
}
```

### 2.2.2 数组的头部是有序的，尾部是无序的

现象：归位几次后，发现已经达到了排序的效果，但循环还在执行；即：数组的前面是有序的，后面是无序的；尾部的几位元素排序完成后，数组就完成了排序；

解决思路：若能够判断数组已经有序，则直接跳出循环；

如何确定有序：内层循环控制交换次数，若在某一次归位时，没有发生交换，则意味着已经达到了排序的效果；

```java
for(int i = 0;i<arr.length-1;i++){  //外层循环，控制归位的次数，n-1次
  boolean flag = true; // 创建boolean类型的变量，flag，默认值为true;
  for(int j = 0;j < arr.length-1-i;j++){  //内层循环，控制比较的次数，n-1次再减已归位的元素个数i-->n-1-i;
    if(a[i] > a[i+1]){   //若左侧的元素大于右侧的元素,则会发生交换
      flag = false;   //若发生了交换，则证明数组还没有完成排序，赋值false；
      int temp = arr[i];
      arr[i] = arr[i+1];
      arr[i+1] = temp;
    }
  }
  if(flag = true){ //在每一次比较元素值后，进行判断，若flag没有发生改变，依然为true，证明以及完成了排序，跳出最外层循环；
  break;
}
```

### 2.2.3 数组的头部是无序的，尾部是有序的

现象：数组的尾部的元素是有序的，头部是无序的；尾部的数据不需要进行多次的交换判断，只需要对头部的数据进行判断并交换，就可以完成对数组的排序；

解决思路：定义一个int类型变量，记录在一次归位中，**最后一次元素交换时的索引号**，作为有序部分与无序部分的分界。在下一次开始交换时，只对无序部分进行交换即可，有序部分则排除在外，不进行交换，提高执行效率；

```java
int lastChangeIndex = 0; //记录最后一次交换时的索引号
int sortBoard = arr.length-1; //存放索引边界，索引号默认为数组最后一位
for(int i=0;i<arr.length-1;i++){
  boolean flag = true;
  for(int j=0;j<sortBoard;j++){ //j<sortBoard：可以防止所以越界，也可以让sortBoard位置上的元素进行比较
    if(arr[j] > arr[j+1]){
      int temp = arr[j];
      arr[j] = arr[j+1];
      arr[j+1] = temp;
      lastChangeIndex = j; //为什么是j不是j+1：因为此处已经完成了交换，将更大的数放在了j+1位置上，较小的数放在了j位置上。下次只需要遍历到j位置即可；
    }
  }
		sortBoard = lastChangeIdex;
  	if(flag == true){
    break;
}
```

